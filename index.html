<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>테트리스</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@300;400;700&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0a0a14;
      --panel: #111128;
      --border: #2a2a55;
      --accent: #6c63ff;
      --accent2: #ff6584;
      --glow: 0 0 20px #6c63ff88;
      --cell: 30px;
    }

    body {
      background: var(--bg);
      color: #e0e0ff;
      font-family: 'Noto Sans KR', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
    }

    /* Animated starfield background */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 50%, #1a1040 0%, transparent 60%),
        radial-gradient(ellipse at 80% 20%, #0d2040 0%, transparent 60%);
      pointer-events: none;
      z-index: 0;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.2rem;
      font-weight: 900;
      letter-spacing: 6px;
      background: linear-gradient(135deg, #6c63ff, #ff6584, #43e8d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      margin-bottom: 20px;
      animation: titlePulse 3s ease-in-out infinite;
      position: relative;
      z-index: 1;
    }

    @keyframes titlePulse {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.3) drop-shadow(0 0 10px #6c63ff); }
    }

    .game-wrapper {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      position: relative;
      z-index: 1;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      letter-spacing: 3px;
      color: #6c63ff;
      text-transform: uppercase;
      margin-bottom: 10px;
      text-align: center;
    }

    /* Main canvas */
    #gameCanvas {
      display: block;
      border: 2px solid var(--border);
      border-radius: 8px;
      box-shadow: var(--glow), inset 0 0 30px rgba(108,99,255,0.05);
      background: #06060f;
    }

    /* Side panels */
    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 14px;
      width: 140px;
    }

    /* Next piece preview */
    #nextCanvas {
      display: block;
      border-radius: 6px;
      margin: 0 auto;
      background: #06060f;
    }

    /* Hold piece */
    #holdCanvas {
      display: block;
      border-radius: 6px;
      margin: 0 auto;
      background: #06060f;
    }

    /* Score display */
    .score-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      font-weight: 700;
      text-align: center;
      color: #fff;
      text-shadow: 0 0 10px #6c63ff;
      letter-spacing: 2px;
    }

    .stat-row {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stat-label {
      font-size: 0.7rem;
      letter-spacing: 2px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .stat-val {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      font-weight: 700;
      color: #e0e0ff;
    }

    /* Controls */
    .controls-list {
      font-size: 0.7rem;
      color: #555;
      line-height: 1.9;
      text-align: left;
    }

    .controls-list span {
      color: #9090cc;
      font-weight: bold;
    }

    /* Overlay */
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(6, 6, 15, 0.88);
      border-radius: 8px;
      z-index: 10;
      backdrop-filter: blur(4px);
    }

    #overlay h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.6rem;
      font-weight: 900;
      letter-spacing: 3px;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #6c63ff, #ff6584);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #overlay p {
      color: #888;
      font-size: 0.85rem;
      margin-bottom: 24px;
      text-align: center;
      line-height: 1.6;
    }

    #overlay .final-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      color: #43e8d8;
      margin-bottom: 20px;
      text-shadow: 0 0 15px #43e8d8;
    }

    .btn {
      background: linear-gradient(135deg, #6c63ff, #9b6cff);
      border: none;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      letter-spacing: 2px;
      padding: 12px 30px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(108,99,255,0.4);
      transition: all 0.2s;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(108,99,255,0.6);
    }

    .btn:active { transform: translateY(0); }

    /* Line clear animation overlay on canvas */
    #flashOverlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      border-radius: 8px;
      opacity: 0;
      background: rgba(255,255,255,0.08);
      transition: opacity 0.15s;
    }

    .canvas-wrap {
      position: relative;
    }

    /* Responsive */
    @media (max-width: 600px) {
      :root { --cell: 22px; }
      h1 { font-size: 1.4rem; letter-spacing: 3px; }
      .side-panel { width: 100px; }
      .score-value { font-size: 1rem; }
    }

    /* Level color indicator bar */
    .level-bar-wrap {
      height: 4px;
      background: #1a1a33;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }

    .level-bar {
      height: 100%;
      background: linear-gradient(90deg, #6c63ff, #ff6584);
      border-radius: 2px;
      transition: width 0.4s ease;
    }
  </style>
</head>
<body>
  <h1>TETRIS</h1>
  <div class="game-wrapper">
    <!-- Left panel -->
    <div class="side-panel">
      <div class="panel">
        <div class="panel-title">홀드</div>
        <canvas id="holdCanvas" width="120" height="90"></canvas>
      </div>
      <div class="panel">
        <div class="panel-title">점수</div>
        <div class="score-value" id="scoreDisplay">0</div>
      </div>
      <div class="panel">
        <div class="stat-row">
          <div class="stat-label">레벨</div>
          <div class="stat-val" id="levelDisplay">1</div>
          <div class="level-bar-wrap" style="width:100%">
            <div class="level-bar" id="levelBar" style="width:0%"></div>
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="stat-row">
          <div class="stat-label">라인</div>
          <div class="stat-val" id="linesDisplay">0</div>
        </div>
      </div>
    </div>

    <!-- Main game -->
    <div class="canvas-wrap panel" style="padding:8px">
      <canvas id="gameCanvas" width="300" height="600"></canvas>
      <div id="flashOverlay"></div>
      <div id="overlay">
        <h2 id="overlayTitle">테트리스</h2>
        <p id="overlayMsg">스페이스바 또는 시작 버튼을 눌러 게임을 시작하세요</p>
        <div class="final-score" id="finalScore" style="display:none"></div>
        <button class="btn" id="startBtn">게임 시작</button>
      </div>
    </div>

    <!-- Right panel -->
    <div class="side-panel">
      <div class="panel">
        <div class="panel-title">다음</div>
        <canvas id="nextCanvas" width="120" height="90"></canvas>
      </div>
      <div class="panel">
        <div class="panel-title" style="margin-bottom:8px">조작키</div>
        <div class="controls-list">
          <span>←→</span> 이동<br>
          <span>↑</span> 회전<br>
          <span>↓</span> 소프트드롭<br>
          <span>Space</span> 하드드롭<br>
          <span>C</span> 홀드<br>
          <span>P</span> 일시정지<br>
          <span>R</span> 재시작
        </div>
      </div>
      <div class="panel">
        <div class="stat-row">
          <div class="stat-label">최고점</div>
          <div class="stat-val" id="highScoreDisplay">0</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ─── Piece definitions ───────────────────────────────────────────────
    const PIECES = [
      // I
      { shape: [[1,1,1,1]], color: '#43e8d8', glow: '#43e8d8' },
      // O
      { shape: [[1,1],[1,1]], color: '#ffd700', glow: '#ffd700' },
      // T
      { shape: [[0,1,0],[1,1,1]], color: '#b44cff', glow: '#b44cff' },
      // S
      { shape: [[0,1,1],[1,1,0]], color: '#6cff8a', glow: '#6cff8a' },
      // Z
      { shape: [[1,1,0],[0,1,1]], color: '#ff6584', glow: '#ff6584' },
      // J
      { shape: [[1,0,0],[1,1,1]], color: '#4c8aff', glow: '#4c8aff' },
      // L
      { shape: [[0,0,1],[1,1,1]], color: '#ff9c4c', glow: '#ff9c4c' },
    ];

    const COLS = 10, ROWS = 20;
    const CELL = 30;
    const SCORE_TABLE = [0, 100, 300, 500, 800];
    const LEVEL_LINES = 10;

    // ─── Canvas setup ────────────────────────────────────────────────────
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');

    // ─── State ────────────────────────────────────────────────────────────
    let board, current, next, hold, score, level, lines, highScore;
    let holdUsed, gameRunning, gamePaused, gameOver;
    let dropInterval, lastTime, dropCounter;
    let animId;
    let particles = [];

    // DOM refs
    const scoreEl = document.getElementById('scoreDisplay');
    const levelEl = document.getElementById('levelDisplay');
    const linesEl = document.getElementById('linesDisplay');
    const highEl  = document.getElementById('highScoreDisplay');
    const levelBar = document.getElementById('levelBar');
    const overlay  = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayMsg   = document.getElementById('overlayMsg');
    const finalScore   = document.getElementById('finalScore');
    const startBtn     = document.getElementById('startBtn');
    const flash        = document.getElementById('flashOverlay');

    // Load high score
    highScore = parseInt(localStorage.getItem('tetris_hs') || '0');
    highEl.textContent = highScore;

    // ─── Bag randomiser (7-bag) ──────────────────────────────────────────
    let bag = [];
    function refillBag() {
      bag = [0,1,2,3,4,5,6];
      for (let i = bag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
    }
    function nextPieceFromBag() {
      if (bag.length === 0) refillBag();
      const idx = bag.pop();
      return spawnPiece(idx);
    }

    function spawnPiece(idx) {
      const p = PIECES[idx];
      return {
        shape: p.shape.map(r => [...r]),
        color: p.color,
        glow: p.glow,
        x: Math.floor((COLS - p.shape[0].length) / 2),
        y: 0,
        idx,
      };
    }

    // ─── Board helpers ────────────────────────────────────────────────────
    function createBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    }

    function isValid(shape, ox, oy) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const x = ox + c, y = oy + r;
          if (x < 0 || x >= COLS || y >= ROWS) return false;
          if (y >= 0 && board[y][x]) return false;
        }
      }
      return true;
    }

    function rotate(shape) {
      const rows = shape.length, cols = shape[0].length;
      const result = Array.from({ length: cols }, () => Array(rows).fill(0));
      for (let r = 0; r < rows; r++)
        for (let c = 0; c < cols; c++)
          result[c][rows - 1 - r] = shape[r][c];
      return result;
    }

    // SRS wall kicks (simplified)
    const KICKS = [
      [[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
      [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
      [[0,0],[1,0],[-2,0],[1,-1],[-2,1]],
      [[0,0],[-1,0],[2,0],[-1,1],[2,-2]],
    ];

    function tryRotate() {
      const rotated = rotate(current.shape);
      for (const [dx, dy] of [[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1],[0,-2]]) {
        if (isValid(rotated, current.x + dx, current.y + dy)) {
          current.shape = rotated;
          current.x += dx;
          current.y += dy;
          return;
        }
      }
    }

    function lockPiece() {
      for (let r = 0; r < current.shape.length; r++) {
        for (let c = 0; c < current.shape[r].length; c++) {
          if (!current.shape[r][c]) continue;
          const y = current.y + r, x = current.x + c;
          if (y < 0) { endGame(); return; }
          board[y][x] = current.color;
        }
      }
      clearLines();
      current = next;
      next = nextPieceFromBag();
      holdUsed = false;
      if (!isValid(current.shape, current.x, current.y)) {
        endGame();
      }
    }

    function clearLines() {
      let cleared = 0;
      const clearIdxs = [];
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(c => c !== null)) {
          clearIdxs.push(r);
          cleared++;
        }
      }
      if (cleared === 0) return;

      // Particle burst
      for (const row of clearIdxs) {
        spawnLineParticles(row);
      }

      // Flash effect
      flash.style.opacity = '1';
      setTimeout(() => { flash.style.opacity = '0'; }, 150);

      // Remove lines
      for (const r of clearIdxs) {
        board.splice(r, 1);
        board.unshift(Array(COLS).fill(null));
      }

      const bonus = SCORE_TABLE[cleared] * level;
      score += bonus;
      lines += cleared;
      level = Math.floor(lines / LEVEL_LINES) + 1;
      dropInterval = Math.max(80, 1000 - (level - 1) * 85);

      levelBar.style.width = ((lines % LEVEL_LINES) / LEVEL_LINES * 100) + '%';
      updateHUD();
    }

    // ─── Particles ────────────────────────────────────────────────────────
    function spawnLineParticles(row) {
      for (let c = 0; c < COLS; c++) {
        for (let i = 0; i < 4; i++) {
          particles.push({
            x: (c + 0.5) * CELL,
            y: (row + 0.5) * CELL,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1,
            decay: 0.03 + Math.random() * 0.03,
            color: `hsl(${Math.random() * 360},100%,70%)`,
            size: 2 + Math.random() * 3,
          });
        }
      }
    }

    function updateParticles(dt) {
      particles = particles.filter(p => {
        p.x += p.vx * dt * 0.06;
        p.y += p.vy * dt * 0.06;
        p.vy += 0.15;
        p.life -= p.decay;
        return p.life > 0;
      });
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // ─── Ghost piece ──────────────────────────────────────────────────────
    function ghostY() {
      let gy = current.y;
      while (isValid(current.shape, current.x, gy + 1)) gy++;
      return gy;
    }

    // ─── Drawing ──────────────────────────────────────────────────────────
    function drawCell(c, x, y, alpha = 1, isGhost = false) {
      const px = x * CELL, py = y * CELL;
      if (isGhost) {
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = c;
        ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = c;
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 1, py + 1, CELL - 2, CELL - 2);
        ctx.globalAlpha = 1;
        return;
      }
      ctx.globalAlpha = alpha;

      // Glow
      ctx.shadowColor = c;
      ctx.shadowBlur = 8;

      // Fill gradient
      const grad = ctx.createLinearGradient(px, py, px + CELL, py + CELL);
      grad.addColorStop(0, lighten(c, 40));
      grad.addColorStop(1, darken(c, 20));
      ctx.fillStyle = grad;
      ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);

      // Inner shine
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(px + 2, py + 2, CELL - 4, 6);

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function lighten(hex, amt) {
      return adjustColor(hex, amt);
    }
    function darken(hex, amt) {
      return adjustColor(hex, -amt);
    }
    function adjustColor(hex, amt) {
      let r = parseInt(hex.slice(1,3),16);
      let g = parseInt(hex.slice(3,5),16);
      let b = parseInt(hex.slice(5,7),16);
      r = Math.min(255, Math.max(0, r + amt));
      g = Math.min(255, Math.max(0, g + amt));
      b = Math.min(255, Math.max(0, b + amt));
      return `rgb(${r},${g},${b})`;
    }

    function drawBoard() {
      // Background grid
      ctx.fillStyle = '#06060f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }

      // Placed blocks
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) drawCell(board[r][c], c, r);
        }
      }
    }

    function drawGhost() {
      const gy = ghostY();
      if (gy === current.y) return;
      for (let r = 0; r < current.shape.length; r++)
        for (let c = 0; c < current.shape[r].length; c++)
          if (current.shape[r][c])
            drawCell(current.color, current.x + c, gy + r, 1, true);
    }

    function drawCurrent() {
      for (let r = 0; r < current.shape.length; r++)
        for (let c = 0; c < current.shape[r].length; c++)
          if (current.shape[r][c])
            drawCell(current.color, current.x + c, current.y + r);
    }

    function drawMini(miniCtx, piece, canvasW, canvasH) {
      miniCtx.fillStyle = '#06060f';
      miniCtx.fillRect(0, 0, canvasW, canvasH);
      if (!piece) return;
      const cs = 22;
      const pw = piece.shape[0].length * cs;
      const ph = piece.shape.length * cs;
      const ox = (canvasW - pw) / 2;
      const oy = (canvasH - ph) / 2;
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (!piece.shape[r][c]) continue;
          const px = ox + c * cs, py = oy + r * cs;
          miniCtx.shadowColor = piece.color;
          miniCtx.shadowBlur = 8;
          const grad = miniCtx.createLinearGradient(px, py, px + cs, py + cs);
          grad.addColorStop(0, lighten(piece.color, 40));
          grad.addColorStop(1, darken(piece.color, 20));
          miniCtx.fillStyle = grad;
          miniCtx.fillRect(px + 1, py + 1, cs - 2, cs - 2);
          miniCtx.shadowBlur = 0;
          miniCtx.fillStyle = 'rgba(255,255,255,0.12)';
          miniCtx.fillRect(px + 2, py + 2, cs - 4, 5);
        }
      }
      miniCtx.shadowBlur = 0;
    }

    function updateHUD() {
      scoreEl.textContent = score.toLocaleString();
      levelEl.textContent = level;
      linesEl.textContent = lines;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('tetris_hs', highScore);
        highEl.textContent = highScore.toLocaleString();
      }
    }

    // ─── Game loop ────────────────────────────────────────────────────────
    function gameLoop(timestamp) {
      if (!gameRunning || gamePaused) return;
      const dt = timestamp - (lastTime || timestamp);
      lastTime = timestamp;
      dropCounter += dt;
      if (dropCounter >= dropInterval) {
        dropCounter = 0;
        if (isValid(current.shape, current.x, current.y + 1)) {
          current.y++;
        } else {
          lockPiece();
        }
      }
      updateParticles(dt);
      drawBoard();
      drawGhost();
      drawCurrent();
      drawParticles();
      drawMini(nextCtx, next, 120, 90);
      drawMini(holdCtx, hold, 120, 90);
      animId = requestAnimationFrame(gameLoop);
    }

    // ─── Controls ────────────────────────────────────────────────────────
    document.addEventListener('keydown', e => {
      if (!gameRunning || gamePaused) {
        if (e.code === 'Space') startGame();
        if (e.key === 'r' || e.key === 'R') startGame();
        return;
      }
      switch (e.code) {
        case 'ArrowLeft':
          e.preventDefault();
          if (isValid(current.shape, current.x - 1, current.y)) current.x--;
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (isValid(current.shape, current.x + 1, current.y)) current.x++;
          break;
        case 'ArrowDown':
          e.preventDefault();
          if (isValid(current.shape, current.x, current.y + 1)) {
            current.y++;
            score += 1;
            updateHUD();
          }
          break;
        case 'ArrowUp':
          e.preventDefault();
          tryRotate();
          break;
        case 'Space':
          e.preventDefault();
          hardDrop();
          break;
        case 'KeyC':
          holdPiece();
          break;
        case 'KeyP':
          togglePause();
          break;
        case 'KeyR':
          startGame();
          break;
      }
    });

    function hardDrop() {
      let dropped = 0;
      while (isValid(current.shape, current.x, current.y + 1)) {
        current.y++;
        dropped++;
      }
      score += dropped * 2;
      updateHUD();
      lockPiece();
    }

    function holdPiece() {
      if (holdUsed) return;
      holdUsed = true;
      if (!hold) {
        hold = { shape: PIECES[current.idx].shape.map(r=>[...r]), color: current.color, glow: current.glow, idx: current.idx };
        current = next;
        next = nextPieceFromBag();
      } else {
        const tmp = { shape: PIECES[current.idx].shape.map(r=>[...r]), color: current.color, glow: current.glow, idx: current.idx };
        current = spawnPiece(hold.idx);
        hold = tmp;
      }
    }

    function togglePause() {
      if (!gameRunning) return;
      gamePaused = !gamePaused;
      if (gamePaused) {
        overlayTitle.textContent = '일시정지';
        overlayMsg.textContent = 'P 키를 눌러 계속하세요';
        finalScore.style.display = 'none';
        startBtn.textContent = '계속하기';
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
        lastTime = null;
        animId = requestAnimationFrame(gameLoop);
      }
    }

    // ─── Start / End ──────────────────────────────────────────────────────
    function startGame() {
      cancelAnimationFrame(animId);
      board = createBoard();
      score = 0; level = 1; lines = 0;
      dropInterval = 800; dropCounter = 0;
      holdUsed = false; hold = null; particles = [];
      gameRunning = true; gamePaused = false; gameOver = false;

      refillBag();
      current = nextPieceFromBag();
      next = nextPieceFromBag();

      levelBar.style.width = '0%';
      updateHUD();
      overlay.style.display = 'none';
      lastTime = null;
      animId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      gameRunning = false;
      gameOver = true;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('tetris_hs', highScore);
        highEl.textContent = highScore.toLocaleString();
      }
      overlayTitle.textContent = '게임 오버';
      overlayMsg.textContent = '수고하셨습니다!';
      finalScore.style.display = 'block';
      finalScore.textContent = score.toLocaleString() + ' 점';
      startBtn.textContent = '다시 시작';
      overlay.style.display = 'flex';

      // Draw final state
      drawBoard();
      drawMini(nextCtx, null, 120, 90);
      drawMini(holdCtx, null, 120, 90);
    }

    // ─── Button ───────────────────────────────────────────────────────────
    startBtn.addEventListener('click', () => {
      if (gamePaused) togglePause();
      else startGame();
    });

    // Initial draw
    drawBoard();
  </script>
</body>
</html>
